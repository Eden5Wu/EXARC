// generateApiProxy.js

const fs = require('fs');
const path = require('path');

// 定義生成檔案的輸出路徑
const OUTPUT_PATH = path.join(__dirname, 'public', 'ajax', 'apiProxy.js');
// apiExecutor.js 相對於 apiProxy.js 的路徑
const API_EXECUTOR_RELATIVE_PATH = './apiExecutor.js';

/**
 * @private
 * 處理 API 呼叫的通用邏輯，包括錯誤處理。
 * 這個函數會被嵌入到生成的 apiProxy.js 中。
 * @param {Function} apiCallFn - 實際執行 API 請求的函數 (e.g., api.get, api.post)。
 * @param {string} endpoint - API 端點名稱。
 * @param {Object} [dataOrParams] - 請求數據或查詢參數。
 * @returns {Promise<Object|string>} 成功時解析為伺服器回應的 JSON 物件或文本。
 * @throws {Error} 如果請求失敗或伺服器返回非 2xx 狀態碼。
 */
const handleApiCallFunctionContent = `
async function handleApiCall(apiCallFn, endpoint, dataOrParams) {
    try {
        const response = await apiCallFn(endpoint, dataOrParams);
        console.log(\`\${endpoint} 成功:\`, response);
        return response;
    } catch (error) {
        console.error(\`\${endpoint} 失敗:\`, error);
        throw error; // 將錯誤重新拋出，讓上層呼叫者處理顯示邏輯
    }
}
`;

/**
 * 生成 apiProxy.js 檔案的函數。
 * 此函數會動態檢查 Express 應用程式的路由，並據此生成前端代理。
 *
 * 注意：由於 Express 的路由堆疊本身不包含詳細的請求參數 schema，
 * 對於參數的推斷，此處需要手動映射或預設處理。
 *
 * @param {import('express').Application} app - Express 應用程式實例。
 */
function generateApiProxyFile(app) {
    // 這個映射表幫助我們推斷已知 API 端點的參數。
    // 在真實的大型應用程式中，這部分可能涉及更複雜的 schema 定義
    // (例如：從 OpenAPI/Swagger 文件解析，或在後端路由定義時額外添加元數據)。
    const endpointParameterMap = {
        'echomsg': { method: 'GET', paramName: 'msg', paramType: 'query' },
        'reversemmsg': { method: 'POST', paramName: 'message', paramType: 'body' }
        // 您可以在此處為未來新增的 API 端點添加映射，以便自動生成正確的參數
        // 例如: 'login': { method: 'POST', paramName: 'credentials', paramType: 'body' }
    };

    let proxyContent = `// This file is auto-generated by the server startup script.\n`;
    proxyContent += `// Do not edit this file directly in development mode.\n\n`;
    proxyContent += `import { api } from '${API_EXECUTOR_RELATIVE_PATH}';\n\n`;
    proxyContent += `/**\n * @private\n * 處理 API 呼叫的通用邏輯，包括錯誤處理。\n */\n`;
    proxyContent += handleApiCallFunctionContent; // 嵌入通用處理函數
    proxyContent += `export const apiProxy = {\n`;

    // 遍歷 Express 路由器堆疊以查找路由
    app._router.stack.forEach(layer => {
        // 檢查層級是否為一個路由
        if (layer.route) {
            const route = layer.route;
            const fullPath = route.path; // 例如: '/api/echomsg'

            // 我們只關心以 '/api/' 開頭的路由
            if (!fullPath.startsWith('/api/')) {
                return;
            }

            // 提取 API 端點的名稱 (例如: 'echomsg')
            const endpointName = fullPath.substring('/api/'.length);

            // 檢查此路由支持哪些 HTTP 方法 (GET, POST 等)
            for (const method in route.methods) {
                if (route.methods[method]) { // 如果該方法被支持 (e.g., { get: true })
                    let paramsDeclaration = ''; // 函數參數的宣告 (e.g., 'msg')
                    let callArguments = 'null'; // 傳遞給 handleApiCall 的參數 (e.g., '{ msg }')
                    let jsdocParams = ''; // JSDoc 參數說明

                    const mappedInfo = endpointParameterMap[endpointName];

                    // 根據映射表或方法類型推斷參數
                    if (mappedInfo && mappedInfo.method.toLowerCase() === method) {
                        if (mappedInfo.paramType === 'query') {
                            paramsDeclaration = mappedInfo.paramName;
                            callArguments = `{ ${mappedInfo.paramName} }`;
                            jsdocParams = `     * @param {string} ${mappedInfo.paramName} - 要傳遞的查詢訊息。\n`;
                        } else if (mappedInfo.paramType === 'body') {
                            paramsDeclaration = mappedInfo.paramName;
                            callArguments = `{ ${mappedInfo.paramName} }`;
                            jsdocParams = `     * @param {Object|string} ${mappedInfo.paramName} - 要傳遞的請求主體數據。\n`;
                        }
                    } else {
                        // 對於不在映射表中的路由，提供一個通用參數
                        paramsDeclaration = 'dataOrParams = {}';
                        callArguments = 'dataOrParams';
                        jsdocParams = `     * @param {Object} [dataOrParams] - 請求數據或查詢參數。\n`;
                    }

                    // 生成此 API 端點的方法程式碼
                    proxyContent += `    /**\n`;
                    proxyContent += `     * 呼叫 ${method.toUpperCase()} /api/${endpointName} API。\n`;
                    if (jsdocParams) {
                        proxyContent += jsdocParams;
                    }
                    proxyContent += `     * @returns {Promise<Object|string>} 回應數據。\n`;
                    proxyContent += `     */\n`;
                    proxyContent += `    ${endpointName}: async (${paramsDeclaration}) => {\n`;
                    proxyContent += `        return handleApiCall(api.${method.toLowerCase()}, '${endpointName}', ${callArguments});\n`;
                    proxyContent += `    },\n\n`;
                }
            }
        }
    });

    proxyContent += `};\n`;

    // 將生成的內容寫入檔案
    fs.writeFileSync(OUTPUT_PATH, proxyContent, 'utf8');
    console.log(`[API Proxy 生成器] ${OUTPUT_PATH} 已成功生成。`);
}

// 匯出函數，以便在 server.js 中調用
module.exports = generateApiProxyFile;
