// generateApiProxy.js (for Node.js)

const listEndpoints = require('express-list-endpoints'); // 導入 express-list-endpoints

const fs = require('fs');
const path = require('path');

// 定義生成檔案的輸出路徑
const OUTPUT_PATH = path.join(__dirname, 'public', 'ajax', 'apiProxy.js');
// apiExecutor.js 相對於 apiProxy.js 的路徑
const API_EXECUTOR_RELATIVE_PATH = './apiExecutor.js';

/**
 * @private
 * 處理 API 呼叫的通用邏輯，包括錯誤處理。
 * 這個函數會被嵌入到生成的 apiProxy.js 中。
 *
 * 修正：此函式現在接收所有可能的參數 (data, queryParams, accept)，
 * 並根據 apiCallFn 的名稱 (get/delete vs. post/put) 調整傳遞給 api 的參數順序。
 *
 * @param {Function} apiCallFn - 實際執行 API 請求的函數 (e.g., api.get, api.post)。
 * @param {string} endpoint - API 端點名稱或已構建的完整路徑。
 * @param {any} [data=null] - 請求主體數據 (用於 POST/PUT)。
 * @param {Object} [queryParams={}] - 查詢參數 (用於 GET/DELETE/POST/PUT)。
 * @param {string|null} [accept=null] - Accept 標頭的值。
 * @returns {Promise<Object|string>} 成功時解析為伺服器回應的 JSON 物件或文本。
 * @throws {Error} 如果請求失敗或伺服器返回非 2xx 狀態碼。
 */
const handleApiCallFunctionContent = `
async function handleApiCall(apiCallFn, endpoint, data = null, queryParams = {}, accept = null) {
    try {
        let response;
        if (apiCallFn.name === 'get' || apiCallFn.name === 'delete') {
            // api.get 和 api.delete 期望參數順序為 (endpoint, queryParams, accept)
            response = await apiCallFn(endpoint, queryParams, accept);
        } else {
            // api.post 和 api.put 期望參數順序為 (endpoint, data, queryParams, accept)
            response = await apiCallFn(endpoint, data, queryParams, accept);
        }

        console.log(\`\${endpoint} 成功:\`, response);
        return response;
    } catch (error) {
        console.error(\`\${endpoint} 失敗:\`, error);
        throw error; // 將錯誤重新拋出，讓上層呼叫者處理顯示邏輯
    }
}
`;

/**
 * 生成 apiProxy.js 檔案的函數。
 * 此函數會動態檢查 Express 應用程式的路由，並據此生成前端代理。
 *
 * @param {import('express').Router} router - Express Router 實例。
 * @param {string} [basePath=''] - 路由掛載的基本路徑。
 */
function generateApiProxyFile(router, basePath = '') {
    // 使用 listEndpoints 函數來獲取路由器的所有端點
    const endpoints = listEndpoints(router);

    if (!endpoints.length) {
        console.warn('[API Proxy 生成器] ⚠ 無可用 API 路由，請確認是否已掛載 Router。');
        return;
    }

    let proxyContent = `// This file is auto-generated by the server startup script.\n`;
    proxyContent += `// Do not edit this file directly in development mode.\n\n`;
    proxyContent += `import { api } from '${API_EXECUTOR_RELATIVE_PATH}';\n\n`;
    proxyContent += `/**\n * @private\n * 處理 API 呼叫的通用邏輯，包括錯誤處理。\n */\n`;
    proxyContent += handleApiCallFunctionContent;
    proxyContent += `export const apiProxy = {\n`;

    // 遍歷 listEndpoints 返回的每個端點
    for (const endpoint of endpoints) {
        // 結合 basePath 和 endpoint.path 得到完整的路由路徑
        const fullPath = basePath + endpoint.path;

        // 僅處理以 /api/ 開頭的路由
        if (!fullPath.startsWith('/api/')) continue;

        // 移除 '/api/' 前綴以獲取端點名稱
        const endpointBase = fullPath.substring('/api/'.length);

        // 遍歷該端點支援的每個 HTTP 方法
        for (const method of endpoint.methods) {
            const httpMethod = method.toLowerCase(); // 轉換為小寫

            let paramsDeclaration = '';    // 例如：'userId, orderId, queryParams = {}'
            let functionBodyContent = '';  // 生成的 async 函數內部內容
            
            // JSDoc 描述
            let jsdocDescription = `呼叫 ${httpMethod.toUpperCase()} /${endpointBase} API。`;
            let jsdocParams = '';          // 例如：'@param {string} userId'

            // 生成 camelCase 的 proxy 方法名稱
            let currentProxyMethodName;
            const pathSegments = endpointBase.split('/');
            
            currentProxyMethodName = pathSegments.map((segment, index) => {
                // 移除路徑參數 (e.g., ':id')
                const cleanedSegment = segment.replace(/:([a-zA-Z0-9_]+)/g, '');
                if (cleanedSegment === '') return ''; // 處理空片段 (例如 // 造成的)

                // 第一個片段保持小寫，後續片段首字母大寫
                if (index === 0) {
                    return cleanedSegment.charAt(0).toLowerCase() + cleanedSegment.slice(1);
                }
                return cleanedSegment.charAt(0).toUpperCase() + cleanedSegment.slice(1);
            }).join('');

            // 處理可能存在的 kebab-case (例如 my-api -> myApi)
            currentProxyMethodName = currentProxyMethodName.replace(/-([a-z])/g, (match, p1) => p1.toUpperCase());

            // 處理非常簡單的路徑，例如 ":id" 或清理後為空字串的情況
            if (!currentProxyMethodName) { 
                 const firstPathParam = endpointBase.match(/:([a-zA-Z0-9_]+)/);
                 if (firstPathParam) {
                    currentProxyMethodName = firstPathParam[1].charAt(0).toLowerCase() + firstPathParam[1].slice(1);
                 } else {
                    currentProxyMethodName = 'rootEndpoint'; 
                 }
            }


            // --- 處理 GET 和 DELETE 請求，包含路徑參數和查詢參數 ---
            if (httpMethod === 'get' || httpMethod === 'delete') {
                const pathParamRegex = /:([a-zA-Z0-9_]+)/g;
                const extractedPathParams = [];
                // 使用 matchAll 確保正確提取所有路徑參數
                for (const matchResult of endpointBase.matchAll(pathParamRegex)) {
                    extractedPathParams.push(matchResult[1]);
                }
                
                // 構建函數簽名的參數列表
                if (extractedPathParams.length > 0) {
                    paramsDeclaration = extractedPathParams.join(', ');
                    jsdocParams += extractedPathParams.map(p => `     * @param {string} ${p} - URL 路徑參數：${p}。\n`).join('');
                }

                // 總是為 GET/DELETE 添加選填的 queryParams 物件 (慣例)
                if (paramsDeclaration) {
                    paramsDeclaration += ', ';
                }
                paramsDeclaration += 'queryParams = {}';
                jsdocParams += `     * @param {Object} [queryParams] - 選填：額外的 URL 查詢參數物件。\n`;
                jsdocParams += `     * @param {string} [accept=null] - 選填：Accept 標頭的值。\n`; // 新增 accept JSDoc

                // 構建傳遞給 api.get 的端點路徑
                const endpointPathEvaluated = endpointBase.replace(pathParamRegex, (match, p) => `\${${p}}`);
                
                // 呼叫 handleApiCall，並傳遞所有參數 (data 為 null)
                functionBodyContent = `        const endpoint = \`${endpointPathEvaluated}\`;\n`;
                functionBodyContent += `        return handleApiCall(api.${httpMethod}, endpoint, null, queryParams, accept);\n`; // 傳遞 null 給 data
                paramsDeclaration += ', accept = null'; // 將 accept 加入參數宣告
            } else { // --- 處理 POST 和 PUT 請求 ---
                // POST/PUT 函數現在將接受 'data' (用於請求體) 和 'queryParams'
                paramsDeclaration = 'data, queryParams = {}, accept = null'; 
                jsdocParams += `     * @param {Object} data - 請求主體數據 (預期為 JSON 物件或陣列)。\n`;
                jsdocParams += `     * @param {Object} [queryParams] - 選填：額外的 URL 查詢參數物件。\n`;
                jsdocParams += `     * @param {string} [accept=null] - 選填：Accept 標頭的值。\n`; // 新增 accept JSDoc

                // 呼叫 handleApiCall，並傳遞所有參數
                functionBodyContent = `        const endpoint = '${endpointBase}';\n`;
                functionBodyContent += `        return handleApiCall(api.${httpMethod}, endpoint, data, queryParams, accept);\n`;
            }

            // 將生成的 API 方法附加到 proxyContent
            proxyContent += `    /**\n`;
            proxyContent += `     * ${jsdocDescription}\n`;
            proxyContent += jsdocParams; // 包含來自上方邏輯的 @param
            proxyContent += `     * @returns {Promise<Object|string>} 回應數據。\n`;
            proxyContent += `     */\n`;
            proxyContent += `    ${currentProxyMethodName}: async (${paramsDeclaration}) => {\n`;
            proxyContent += functionBodyContent;
            proxyContent += `    },\n\n`;
        }
    }

    proxyContent += `};\n`;

    // 將生成的內容寫入檔案
    fs.writeFileSync(OUTPUT_PATH, proxyContent, 'utf8');
    console.log(`[API Proxy 生成器] ${OUTPUT_PATH} 已成功生成。`);
}

// 匯出函數，以便在 server.js 中調用
module.exports = generateApiProxyFile;
